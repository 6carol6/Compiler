%option yylineno
yylineno = 1

%{
	int is_show_syntax_tree = 1;
	int yycolumn = 1;
	
	#define YY_USER_ACTION yylloc.first_line = yylloc.last_line = yylineno;\
	yylloc.first_column = yycolumn;yylloc.last_column = yycolumn+yyleng-1;\
	yycolumn += yyleng;
	#include "syntax.tab.h"
	#include "Node.h"
	#include <stdio.h>
	extern void create_tree_node(struct Node** node, char* name, char* subname, int is_show);
%}

delim	[ \t]
ws	{delim}+
relop	>|>=|<|<=|==|!=
letter	[A-Za-z]
letter_	[A-Za-z_]
digit	[0-9]
oct     0[0-7]+
hex	0[xX][0-9A-Fa-f]+
type	int|float
int     0|[1-9]{digit}*|{oct}|{hex}
float	{int}\.{digit}+
id	{letter_}({letter_}|{digit})*

%%
{ws}	{}
\n	{ yycolumn = 1;}
{int}	{ create_tree_node(&yylval.treeNode, "INT", yytext, 0);return INT; }
{float}	{ create_tree_node(&yylval.treeNode, "FLOAT", yytext, 0);return FLOAT; }
";"	{ create_tree_node(&yylval.treeNode, "SEMI", "", 0);return SEMI; }
","	{ create_tree_node(&yylval.treeNode, "COMMA", "", 0);return COMMA; }
"="	{ create_tree_node(&yylval.treeNode, "ASSIGNOP", "", 0);return ASSIGNOP; }
{relop}	{ create_tree_node(&yylval.treeNode, "RELOP", "", 0);return RELOP; }
"+"	{ create_tree_node(&yylval.treeNode, "PLUS", "", 0);return PLUS; }
"-"	{ create_tree_node(&yylval.treeNode, "MINUS", "", 0);return MINUS; }
"*"	{ create_tree_node(&yylval.treeNode, "STAR", "", 0);return STAR; }
"/"	{ create_tree_node(&yylval.treeNode, "DIV", "", 0);return DIV; }
"&&"	{ create_tree_node(&yylval.treeNode, "AND", "", 0);return AND; }
"||"	{ create_tree_node(&yylval.treeNode, "OR", "", 0);return OR; }
"."	{ create_tree_node(&yylval.treeNode, "NOT", "", 0);return DOT; }
"!"	{ create_tree_node(&yylval.treeNode, "NOT", "", 0);return NOT; }
{type}	{ create_tree_node(&yylval.treeNode, "TYPE", yytext, 0);return TYPE; }
"("	{ create_tree_node(&yylval.treeNode, "LP", "", 0);return LP; }
")"	{ create_tree_node(&yylval.treeNode, "RP", "", 0);return RP; }
"["	{ create_tree_node(&yylval.treeNode, "LB", "", 0);return LB; }
"]"	{ create_tree_node(&yylval.treeNode, "RB", "", 0);return RB; }
"{"	{ create_tree_node(&yylval.treeNode, "LC", "", 0);return LC; }
"}"	{ create_tree_node(&yylval.treeNode, "RC", "", 0);return RC; }
"struct"	{ create_tree_node(&yylval.treeNode, "STRUCT", "", 0);return STRUCT; }
"return"	{ create_tree_node(&yylval.treeNode, "RETURN", "", 0);return RETURN; }
"if"	{ create_tree_node(&yylval.treeNode, "IF", "", 0);return IF; }
"else"	{ create_tree_node(&yylval.treeNode, "ELSE", "", 0);return ELSE; }
"while"	{ create_tree_node(&yylval.treeNode, "WHILE", "", 0);return WHILE; }
{id}	{ create_tree_node(&yylval.treeNode, "ID", yytext, 0);return ID; }
.	{
		is_show_syntax_tree = 0;
		printf("Error type A at line %d: Mysterious character \'%s\'\n", yylineno, yytext);
	}
%%
void create_tree_node(struct Node** node, char* name, char* subname, int is_show){
	*node = (struct Node*)malloc(sizeof(struct Node));
	(*node)->name = name;
	(*node)->subname = (char*)malloc(sizeof(char)*10);
	strcpy((*node)->subname, subname);
	(*node)->line_num = yylineno;
	(*node)->show_line_num = is_show;
	(*node)->brother = NULL;
	(*node)->children = NULL;
}
